#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import argparse
from pathlib import Path

import plotly.graph_objects as go
from dash import Dash
from dash import Input
from dash import Output
from dash import callback
from dash import dcc
from dash import html

from plant3dvision.visu import plotly_direction_data
from plant3dvision.visu import plotly_mesh_data
from plant3dvision.visu import plotly_pointcloud_data
from plant3dvision.visu import plotly_treegraph_data
from plantdb import FSDB
from plantdb.io import read_graph
from plantdb.io import read_json
from plantdb.io import read_point_cloud
from plantdb.io import read_triangle_mesh
from plantdb.log import configure_logger

TASKS = [
    "PointCloud",
    "TriangleMesh",
    "CurveSkeleton",
    "TreeGraph",
    "AnglesAndInternodes",
]


def parsing():
    parser = argparse.ArgumentParser(description="Explore the tasks outputs on selected dataset.")
    parser.add_argument('dataset', type=str,
                        help="Path to the dataset to explore (directory)")

    app_args = parser.add_argument_group("Dash app options")
    app_args.add_argument('--port', type=int, default=8080,
                          help="Port used to serve the application.")
    app_args.add_argument('--host', type=str, default="127.0.0.1",
                          help="Port used to serve the application.")
    app_args.add_argument('--docker', action="store_true",
                          help="Use it to indicate that the app in running in a container.")

    return parser


def get_data(dataset):
    dataset = Path(dataset)
    db_path = dataset.parent
    dataset_name = dataset.name
    db = FSDB(db_path)
    db.connect()
    scan = db.get_scan(dataset_name, create=False)
    # List all fileset in the scan
    fs_list = scan.list_filesets()
    # Find the fileset corresponding to the task:
    fileset_names = {}
    for task in TASKS:
        try:
            fileset_names[task] = [fs for fs in fs_list if fs.startswith(task)][0]
        except IndexError:
            fileset_names[task] = "None"

    # - Load the PointCloud:
    pcd = None
    pcd_fs = scan.get_fileset(fileset_names['PointCloud'])
    try:
        pcd_file = pcd_fs.get_file('PointCloud')
        pcd = read_point_cloud(pcd_file)
    except:
        logger.warning(f"Could not find a 3D point cloud to load!")
    else:
        logger.info(f"Found a 3D point cloud to load: '{pcd_file.filename}'.")

    # - Load the TriangleMesh:
    mesh = None
    mesh_fs = scan.get_fileset(fileset_names['TriangleMesh'])
    try:
        mesh_file = mesh_fs.get_file('TriangleMesh')
        mesh = read_triangle_mesh(mesh_file)
    except:
        logger.warning(f"Could not find a 3D triangular mesh to load!")
    else:
        logger.info(f"Found a 3D triangular mesh to load: '{mesh_file.filename}'.")

    # - Load the TreeGraph:
    tree = None
    tree_fs = scan.get_fileset(fileset_names['TreeGraph'])
    try:
        tree_file = tree_fs.get_file('TreeGraph')
        tree = read_graph(tree_file)
    except:
        logger.warning(f"Could not find a 3D tree graph to load!")
    else:
        logger.info(f"Found a 3D tree graph to load: '{tree_file.filename}'.")

    # - Load the estimated fruit directions:
    fruit_dir = None
    fruit_dir_fs = scan.get_fileset(fileset_names['AnglesAndInternodes'])
    try:
        fruit_dir_file = fruit_dir_fs.get_file('fruit_direction')
        fruit_dir = read_json(fruit_dir_file)
    except:
        logger.warning(f"Could not find a list of fruit directions to load!.")
    else:
        logger.info(f"Found a list of fruit directions to load: '{fruit_dir_file.filename}'.")

    db.disconnect()
    return pcd, mesh, tree, fruit_dir


def get_graph_objects(data):
    go_data = {}

    go_data['PointCloud'] = plotly_pointcloud_data(data['PointCloud'])
    go_data['TriangleMesh'] = plotly_mesh_data(data['TriangleMesh'])
    go_data['TreeGraph'] = plotly_treegraph_data(data["TreeGraph"])
    fruit_dir = data["FruitDirection"]
    go_data['FruitDirection'] = plotly_direction_data(fruit_dir["fruit_dirs"], fruit_dir["bp_coords"], "fruit")

    return go_data


def select_go_data(checklist, go_data):
    selected_go_data = []
    for name in checklist:
        if isinstance(go_data[name], list):
            selected_go_data.extend(go_data[name])
        else:
            selected_go_data.append(go_data[name])
    return selected_go_data


def dash_app(data):
    app = Dash(__name__)

    go_data = get_graph_objects(data)
    init_checklist = list(go_data.keys())
    checklist = dict(zip(go_data.keys(), init_checklist))
    fig = go.Figure(data=select_go_data(checklist, go_data))

    fig.update_scenes(aspectmode='data')

    app.layout = html.Div([
        html.Link(href="https://fonts.googleapis.com/css?family=Nunito Sans", rel="stylesheet"),
        html.H1(children='Plant reconstruction explorer', style={'textAlign': 'center', 'padding': '10px 10px', 'background-color': 'rgb(30 179 123)'}),
        dcc.Checklist(list(data.keys()), inline=True, value=init_checklist, id='checklist-selection', style={'margin': "auto"}),
        dcc.Graph(figure=fig, id='graph-content', style={'width': '98vw', 'height': '95vh'}, config={'responsive': True})
    ], style={'font-family': '"Nunito Sans"'})

    @callback(
        Output('graph-content', 'figure'),
        Input('checklist-selection', 'value')
    )
    def update_graph(value):
        fig = go.Figure(data=select_go_data(value, go_data))
        fig.update_scenes(aspectmode='data')
        return fig

    return app


if __name__ == '__main__':
    # - Parse the input arguments to variables:
    parser = parsing()
    args = parser.parse_args()

    # - Configure a logger from this application:
    global logger
    logger = configure_logger('dash_explorer')

    pcd, mesh, tree, fruit_dir = get_data(args.dataset)
    data = {
        "PointCloud": pcd,
        "TriangleMesh": mesh,
        "TreeGraph": tree,
        "FruitDirection": fruit_dir
    }

    app = dash_app(data)
    if args.docker:
        args.host="0.0.0.0"

    app.run(debug=True, host=args.host, port=args.port)
